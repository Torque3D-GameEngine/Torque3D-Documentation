<html xmlns="http://www.w3.org/1999/xhtml">
<HEAD><SCRIPT SRC="../../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/glossaryLookUp.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/referenceLookUp.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/componentContainer.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../../";</SCRIPT><link href="../../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/referenceThemeStyle.css" rel="stylesheet" type="text/css" />
<link href="../../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 22;
   parent.leftFrame.expandToItem('tree2', 'doc22');
   var element = parent.leftFrame.document.getElementById('doc22');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script>
    <title>Torque 3D/Engine/LightInfo</title>

<link rel="stylesheet" type="text/css" href="../../../include/container.css" />
<link rel="stylesheet" type="text/css" href="../../../include/content.css" />

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<BODY id = "BODYID" onLoad = "initComponent()"  style="width: 700; padding: 10px" class="mediawiki ltr ns-0 ns-subject page-Torque3D_LightingOverview_GFX_Interface skin-monobook">

<h2><span class="mw-headline">LightInfo Class Reference</span></h2>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    unpackExtended( BitStream * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Will traverse the vector of LightInfoEx pointers (mExtended) and call their individual unpackUpdate function with the passed in stream as a parameter.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    unpackExtended( BitStream *stream )isCompatible()
    <br />
    <ul>
        <li><strong>stream:</strong> Used to pass to the individual calls of the unpackUpdate through the traversed mExtended.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From LightBase::unpackUpdate
mLight->unpackExtended( stream );
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    packExtended( BitStream * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Will traverse the vector of LightInfoEx pointers (mExtended) and call their individual packUpdate function with the passed in stream as a parameter.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    packExtended( BitStream *stream )
    <br />
    <ul>
        <li><strong>stream:</strong> Used to pass to the individual calls of the packUpdate through the traversed mExtended.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From LightNase::packUpdate at lightBase.cpp
mLight->packExtended( stream ); 
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    packExtended( BitStream * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Will traverse the vector of LightInfoEx pointers (mExtended) and call their individual packUpdate function with the passed in stream as a parameter.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    packExtended( BitStream *stream )
    <br />
    <ul>
        <li><strong>stream:</strong> Used to pass to the individual calls of the packUpdate through the traversed mExtended.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From LightNase::packUpdate at lightBase.cpp
mLight->packExtended( stream ); 
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    getWorldToLightProj( MatrixF * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Builds the world to light view projected used for shadow texture and cookie lookups.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    getWorldToLightProj( MatrixF *outMatrix )
    <br />
    <ul>
        <li><strong>outMatrix:</strong> The generated Matrix, if the type of the light is a spot then this matrix will be created by multiplying the cone projection by the inverse transform of the light. If the type of the light is not a Spot, then the Matrix will be assigned to the inverse of the light.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From AdvancedLightManager::setLightInfo
MatrixF proj;
light->getWorldToLightProj( &proj );
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    deleteAllLightInfoEx()
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Deletes all LightInfoEx objects.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    deleteAllLightInfoEx()
    <br />
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From the destructor of LightInfo
deleteAllLightInfoEx();
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    addExtended( LightInfoEx * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Will add the passed in LightInfoEx * to the current vector of LightInfo * (mExtended) if it is not null.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    addExtended( LightInfoEx *lightInfoEx )
    <br />
    <ul>
        <li><strong>lightInfoEx:</strong> Will be added to mExtended.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// AdvancedLightManager::_addLightInfoEx from advancedLightManager.cpp
lightInfo->addExtended( new ShadowMapParams( lightInfo ) );
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    getExtended( const LightInfoExType & )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Will return the LightInfoEx * mExtended based upon the LightInfoExType passed in.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    getExtended( const LightInfoExType &type )
    <br />
    <ul>
        <li><strong>type:</strong> The type of a LightInfoEx to be used to return the LightInfoExType.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <ul>
        <li><strong>LightInfoEx *:</strong> The LightInfoEx * from mExtended with regards to the type passed in.</li>
    </ul>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From CubeLightShadowMap::setShaderParameters at cubeLightShadowMap.cpp
ShadowMapParams *p = mLight->getExtended&lt;ShadowMapParams&gt;();
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    setGFXLight( GFXLightInfo * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Sets a fixed function GFXLight with the properties on this class.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    setGFXLight(GFXLightInfo *light )
    <br />
    <ul>
        <li><strong>light:</strong> The light that will have its properties filled in based upon the properties of this class.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    <strong><em>Examples</em></strong>
<pre>
// From ProcessedFFMaterial::_setPrimaryLightInfo at porcessedFFMaterial.cpp
GFXLightInfo xlatedLight;
light->setGFXLight(&xlatedLight);
</pre>
    </td>
</tr>
</tbody>
</table>

<br />

<table style="width: 700">
<tbody>
<tr>
<td style="padding: 10px; font-weight: bold; background-color: #3399FF">
    set( const LightInfo * )
</td>
</tr>
<tr>
<td style="padding: 10px; background-color: #CCCCCC">
    <p>Copies the data passed in from the LightInfo passed in, such as the properties and the contents of mExtended.</p>
    <br />
    <br />
    <strong><em>Syntax</em></strong><br />
    <br />
    set(const LightInfo *light )
    <br />
    <ul>
        <li><strong>light:</strong> The light in which the information to be set to this class should be obtained from.</li>
    </ul>
    <br />
    <strong>Returns</strong>
    <br />
    <p>No return value.</p>
    <br />
    </td>
</tr>
</tbody>
</table>

<div class="footer">   <a href="../../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div></body>
</html>
